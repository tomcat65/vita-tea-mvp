# Story 2.1: Shopping Cart Management

## Status

Draft

## Story

**As a** customer,
**I want** the ability to add products to cart and modify quantities,
**so that** I can build my order before checkout.

## Acceptance Criteria

1. Add to cart functionality for all three sample trio products
2. Cart persistence across browser sessions using Firestore
3. Quantity modification and item removal capabilities
4. Real-time price calculations with tax estimates
5. Cart summary display with product details and totals
6. Mobile-optimized cart interface with touch-friendly controls

## Tasks / Subtasks

- [ ] Create cart service module with Firestore integration (AC: 1, 2)
  - [ ] Implement authenticated user cart sync with Firestore
  - [ ] Implement guest cart with localStorage persistence
  - [ ] Create cart merge logic for guest to authenticated transition
  - [ ] Set up real-time Firestore listeners for cart updates
- [ ] Build Alpine.js cart state store (AC: 2, 4)
  - [ ] Define cart store structure with items array and totals
  - [ ] Implement reactive state management with Alpine.effect
  - [ ] Create cart calculation methods (subtotal, tax, total)
  - [ ] Handle authenticated vs guest cart switching
- [ ] Create cart page HTML structure (AC: 5, 6)
  - [ ] Design responsive cart layout with product list
  - [ ] Include product images, names, prices, quantities
  - [ ] Add order summary section with totals breakdown
  - [ ] Implement empty cart state with CTA to shop
- [ ] Develop cart item Web Component (AC: 3, 5, 6)
  - [ ] Create custom element with shadow DOM
  - [ ] Implement quantity selector with increment/decrement
  - [ ] Add remove item functionality with confirmation
  - [ ] Display line item totals with quantity changes
- [ ] Implement add to cart functionality (AC: 1)
  - [ ] Create add to cart buttons on product pages
  - [ ] Handle product ID and quantity capture
  - [ ] Show success feedback on cart addition
  - [ ] Update cart icon/badge with item count
- [ ] Add real-time price calculations (AC: 4)
  - [ ] Calculate subtotal from items and quantities
  - [ ] Implement tax calculation based on location (placeholder)
  - [ ] Display shipping cost estimates
  - [ ] Show grand total with all costs included
- [ ] Optimize for mobile experience (AC: 6)
  - [ ] Ensure touch-friendly button sizes (min 44px)
  - [ ] Implement swipe-to-delete gesture for items
  - [ ] Create mobile-optimized quantity selectors
  - [ ] Test responsive layout across breakpoints
- [ ] Create manual test checklist
  - [ ] Test add to cart for each product type
  - [ ] Verify cart persistence after page refresh
  - [ ] Test quantity updates and item removal
  - [ ] Validate calculations are accurate
  - [ ] Test guest to authenticated cart merge
  - [ ] Verify mobile UI responsiveness

## Dev Notes

### Cart State Management
[Source: architecture/frontend-architecture.md#state-management]
```javascript
Alpine.store('cart', {
  items: [],
  total: 0,
  
  init() {
    Alpine.effect(() => {
      const user = Alpine.store('user');
      if (user.isAuthenticated) {
        this.subscribeToCart(user.uid);
      } else {
        this.loadGuestCart();
      }
    });
  },
  
  subscribeToCart(userId) {
    return firebase.firestore()
      .collection('carts')
      .doc(userId)
      .onSnapshot(doc => {
        if (doc.exists) {
          this.items = doc.data().items || [];
          this.calculateTotal();
        }
      });
  },
  
  loadGuestCart() {
    const saved = localStorage.getItem('guest-cart');
    this.items = saved ? JSON.parse(saved) : [];
    this.calculateTotal();
  }
});
```

### Firestore Cart Structure
[Source: architecture/database-schema.md#carts-collection]
```javascript
// Collection: carts
{
  "cartId": "user_uid", // Document ID matches user's UID
  "userId": "user_uid",
  "items": [
    {
      "productId": "product_123",
      "quantity": 2,
      "addedAt": Timestamp
    }
  ],
  "expiresAt": Timestamp, // 7 days from last update
  "createdAt": Timestamp,
  "updatedAt": Timestamp
}
```

### Cart Data Models
[Source: architecture/data-models.md#cart-models]
```typescript
interface Cart {
  cartId: string;
  userId: string;
  items: CartItem[];
  expiresAt: Timestamp;
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

interface CartItem {
  productId: string;
  quantity: number;
  addedAt: Timestamp;
}
```

### Cart Service Operations
[Source: architecture/frontend-architecture.md#firebase-service]
```javascript
async addToCart(productId, quantity) {
  const user = this.auth.currentUser;
  if (!user) {
    // Handle guest cart
    CartService.addToGuestCart(productId, quantity);
    return;
  }
  
  const cartRef = this.db.collection('carts').doc(user.uid);
  return cartRef.set({
    items: firebase.firestore.FieldValue.arrayUnion({
      productId,
      quantity,
      addedAt: firebase.firestore.Timestamp.now(),
    }),
    updatedAt: firebase.firestore.Timestamp.now(),
  }, { merge: true });
}
```

### Cart Item Web Component Pattern
[Source: architecture/components.md#web-components]
Shopping Cart Component must implement:
- `addToCart(productId, quantity)`
- `updateCartItem(productId, newQuantity)`
- `removeFromCart(productId)`
- `getCartTotal()` - Calculate totals
- `subscribeToCart()` - Real-time cart sync

### Session Persistence Strategy
[Source: architecture/database-schema.md#cart-management]
- Cart documents expire after 7 days of inactivity
- Guest carts stored in localStorage, merged on signup
- Real-time sync between devices for logged-in users

### File Locations
Based on project structure [Source: architecture/unified-project-structure.md]:
- `/public/cart.html` - Cart page
- `/public/js/cart.js` - Cart controller 
- `/public/js/components/cart-item.js` - Cart item Web Component
- `/public/js/services/cart.service.js` - Cart service layer
- `/public/js/stores/cart.store.js` - Alpine.js cart store

### Previous Story Insights
From Story 1.5 implementation:
- Successfully used Alpine.js stores for state management
- Web Components pattern proven effective for reusable UI
- Analytics tracking should be added for cart events
- Mobile-first approach with responsive breakpoints
- Manual testing checklist approach established

### Technical Constraints
[Source: architecture/tech-stack.md]
- Frontend: Vanilla JavaScript with Alpine.js for reactivity
- No build tools or bundlers
- Web Components for reusable UI elements
- Firestore for real-time data synchronization
- LocalStorage for guest persistence

## Testing

### Test Standards
[Source: architecture/testing-strategy.md#frontend-testing]
- **Test Location**: Manual test checklists in `/docs/testing/`
- **Test Framework**: Manual testing only for MVP (no Jest/Cypress)
- **Browser Testing**: Chrome, Firefox, Safari (mobile and desktop)
- **Performance**: Cart operations < 500ms response time
- **Accessibility**: Keyboard navigation and screen reader support
- **Device Testing**: Test on iOS/Android mobile devices

### Integration Test Example
[Source: architecture/testing-strategy.md#integration-tests]
```javascript
it('completes purchase successfully', async () => {
  // Add to cart
  await firebase.firestore()
    .collection('carts')
    .doc('test-user')
    .set({
      items: [{ productId: 'tea123', quantity: 1 }],
    });
  
  // Create payment intent
  const createIntent = firebase.functions()
    .httpsCallable('stripeCreateIntent');
  const result = await createIntent({ shippingAddress: mockAddress });
  
  expect(result.data).to.have.property('clientSecret');
  expect(result.data).to.have.property('orderId');
});
```

### Manual Test Checklist Requirements
[Source: architecture/testing-strategy.md#manual-testing]
Must include tests for:
- Add to cart (logged in)
- Add to cart (guest)
- Cart persistence across sessions
- Quantity updates and calculations
- Mobile responsiveness
- Error handling scenarios

## Change Log

| Date       | Version | Description           | Author           |
| ---------- | ------- | --------------------- | ---------------- |
| 2025-08-27 | 1.0     | Initial story creation | Scrum Master Bob |

## Dev Agent Record

_This section will be populated by the development agent during implementation_

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_This section will be populated by the QA agent after implementation review_